---
title: "CITS5507 Project 1: Parallel implementation of search based on Fish School Behaviour"

graphics: yes
author: Kaiqi Liang (23344153), Briana Davies-Morrell (22734723)
date: "Semester 2, 2023"

output:
  html_document:
    number_sections: true
---

```{r, message=FALSE, warning=FALSE, echo=FALSE}
library(ggplot2)
```

# Introduction
Fish School Behavior (FSB) is a heuristic algorithm used for multi-dimensional optimization problems. The objective of this project was to parallelize the FSB algorithm and perform experiments, changing the hyperparameters and parallelisation strategies. 

# Experimental Setup

## Sequential Implementation

To establish a baseline for comparison, a sequential C program was developed to simulate the behavior of a fish school using the FSB algorithm. 

INSERT A GRAPH / EXECUTION TIME?

## Parallel Implementation

The parallel implementation was developed using OpenMP. We explored the following aspects of the parallelization process:

1. Number of Threads

2. Hyperparameters: Number of Fish & Iterations

3. Thread Scheduling

4. OMP Directives 


# Experimental Results

## Number of Threads

In our first experiment, we aimed to assess the impact of varying the number of threads on the parallelized FSB algorithm's performance while keeping hyperparameters and thread scheduling constant. Specifically, we maintained the number of fish at 1,000,000, the number of iterations at 100,000, and used a static scheduling strategy. We did not employ caching since it was not the focus of this experiment.

From the results, provided below, it was observed that the sequential implementation had the fastest execution time, potentially due to the absence of thread management overhead. Some speedup was achieved by increasing the thread count from 2 to 4, but beyond 4 threads, the speedup plateaued with the execution time remaining relatively stable, indicating diminishing returns in terms of parallelization efficiency. This decline in performance can be attributed to increased overhead from thread management.


```{r, message=FALSE, warning=FALSE, echo=FALSE}
ggplot(
    data.frame(
      num_threads = c(1, 2, 4, 6, 8, 16),
      parallel = c(
        3220.587380,
        3471.353496,
        2925.219894,
        2944.861335,
        2929.350958,
        3000.694720),
      sequential = 2780.588561),
    aes(x = num_threads)) +
    ggtitle("Execution Time vs Number of Threads") +
    labs(x = "Number of Threads",
      y = "Time (s)",
      linetype = "Parallel / Sequential") +
    geom_smooth(aes(y = sequential, linetype = "sequential")) +
    geom_smooth(aes(y = parallel, linetype = "parallel")) +
    geom_point(aes(y = parallel)) +
    scale_y_continuous(breaks = c(
      setdiff(seq(2700, 3500, by = 100), 2800),
      2780)) +
    scale_x_continuous(breaks = 1:16)
```

## Hyperparameters: Number of Fish & Iterations

In the second experiment, we assessed the impact of varying two critical hyperparameters, the number of fish and the number of iterations, on the execution time of the parallel FSB algorithm. The number of threads fixed at 4 and a static scheduling strategy was employed. The number of threads was fixed to 4, as this was the optimal number achieved in the previous experiement. Similar to the first experiment, caching was not employed.

The graph below visualizes the execution time over a combination of different number of fishes and iterations, with the x-axis represent the number of fishes and each line representing the number of iterations ran in a given experiment. As evident from the graph, increasing both the number of fish and the number of iterations leds to an exponential growth in execution time. This behavior is expected, as a larger population of fish and more iterations require more computation, resulting in longer execution times.

```{r, message=FALSE, warning=FALSE, echo=FALSE}

ggplot(
  data = data.frame(
    num_fish =  c(200000, 400000, 600000, 800000, 1000000),
    iter_20000 = c(117.350819,237.082449,397.935612,482.203047, 653.402037),
    iter_40000 = c(234.463991,466.925614,700.021926,936.720754,1177.662832),
    iter_60000 = c(353.012268,701.901361,1050.975947,1418.876797,1777.164701),
    iter_80000 = c(471.402103,944.524666,1397.776130,1863.592248,2350.380621),
    iter_100000 = c(586.554482, 1167.285182, 1771.424057,2363.592248, 2925.219894)),
  aes(x = num_fish)) +
  geom_smooth(aes(y = iter_20000, color = "20000")) +
  geom_smooth(aes(y = iter_40000, color = "40000")) +
  geom_smooth(aes(y = iter_60000, color = "60000")) +
  geom_smooth(aes(y = iter_80000, color = "80000")) +
  geom_smooth(aes(y = iter_100000, color = "100000")) +
  geom_point(aes(y = iter_20000)) +
  geom_point(aes(y = iter_40000)) +
  geom_point(aes(y = iter_60000)) +
  geom_point(aes(y = iter_80000)) +
  geom_point(aes(y = iter_100000)) +
  ggtitle("Execution Time vs Hyperparameters") +
  labs(x = "Number of Fish",
    y = "Time (s)",
    color = "Number of Iterations") +
  scale_color_manual(values = c(
    "20000" = "darkred",
    "40000" = "steelblue",
    "60000" = "magenta",
    "80000" = "darkgreen",
    "100000" = "pink4"))
```

## Thread Scheduling

In the third experiment, we investigated the impact of different thread scheduling strategies (static, dynamic, guided, and runtime) on the execution time of the parallelized FSB algorithm. The number of threads was fixed at 4, and the hyperparameters of number of fish and iterations were also kept constant at 1,000,000 and 100,000 respectively. 

```{r, message=FALSE, warning=FALSE, echo=FALSE}
ggplot(
  data = data.frame(
    chunk_size = c(1, 2, 3, 4),
    static = c(3265.162540, 2784.864581, 3035.950782, 2918.142244),
    dynamic = c(4154.18010, 3073.691588, 2970.014433, 2982.671884),
    guided = c(3051.865076, 2937.002249, 2941.794308, 2973.637886),
    runtime = 4198.46404),
  aes(x = chunk_size)) +
  geom_smooth(aes(y = static, color = "static")) +
  geom_smooth(aes(y = dynamic, color = "dynamic")) +
  geom_smooth(aes(y = guided, color = "guided")) +
  geom_smooth(aes(y = runtime, color = "runtime")) +
  geom_point(aes(y = static)) +
  geom_point(aes(y = dynamic)) +
  geom_point(aes(y = guided)) +
  ggtitle("Execution Time vs Scheduling Strategies") +
  labs(x = "Chunk Size",
    y = "Time (s)",
    color = "Scheduling Type") +
  scale_x_continuous(labels = c(1, 10, 100, 10000)) +
  scale_y_continuous(breaks = seq(2700, 4200, by = 300)) +
  scale_color_manual(values = c(
    "static" = "darkred",
    "dynamic" = "steelblue",
    "guided" = "magenta",
    "runtime" = "darkgreen"))
```

Fix everything but different implementation of tasks vs partition and simple parallel for
