---
title: "CITS5507 Project 1: Parallel implementation of search based on Fish School Behaviour"

graphics: yes
author: Kaiqi Liang (23344153), Briana Davies-Morrell (22734723)
date: "Semester 2, 2023"

output:
  html_document:
    number_sections: true
---

```{r, message=FALSE, warning=FALSE, echo=FALSE}
library(ggplot2)
```

# Introduction
Fish School Behaviour (FSB) is a heuristic algorithm used for multi-dimensional optimization problems. The objective of this project was to parallelize a simple version of the FSB algorithm and perform experiments, changing the hyperparameters and parallelisation strategies.

# Experimental Setup

## Sequential Implementation

To establish a baseline for comparison, a sequential C program was developed to simulate the behavior of a fish school using the FSB algorithm. 

INSERT A GRAPH / EXECUTION TIME?

## Parallel Implementation

The parallel implementation was developed using OpenMP. We explored the following aspects of the parallelization process:

1. Number of Threads

2. Hyperparameters: Number of Fish & Iterations

3. Thread Scheduling

4. Parallel Implementations using different OMP Directives


# Experimental Results

## Number of Threads

In our first experiment, we aimed to assess the impact of varying the number of threads on the parallelized FSB algorithm's performance while keeping hyperparameters and thread scheduling constant. Specifically, we maintained the number of fish at 1,000,000, the number of iterations at 100,000, and used a static scheduling strategy. We did not employ caching since it was not the focus of this experiment.

From the results, provided below, it was observed that the sequential implementation had the fastest execution time, potentially due to the absence of thread management overhead. Some speedup was achieved by increasing the thread count from 2 to 4, but beyond 4 threads, the speedup plateaued with the execution time remaining relatively stable, indicating diminishing returns in terms of parallelization efficiency. This decline in performance can be attributed to increased overhead from thread management.


```{r, message=FALSE, warning=FALSE, echo=FALSE}
ggplot(
    data.frame(
      num_threads = c(1, 2, 3, 4, 5, 6, 8, 16),
      parallel = c(
        3220.587380,
        3471.353496,
        2984.539602,
        2925.219894,
        2944.861335,
        2977.993479,
        2929.350958,
        3000.694720),
      sequential = 2780.588561),
    aes(x = num_threads)) +
    labs(title = "Execution Time vs Number of Threads",
      x = "Number of Threads",
      y = "Time (s)",
      linetype = "Parallel / Sequential") +
    geom_smooth(aes(y = sequential, linetype = "sequential")) +
    geom_line(aes(y = parallel, linetype = "parallel")) +
    geom_point(aes(y = parallel)) +
    scale_y_continuous(breaks = c(
      seq(2900, 3500, by = 100), 2780)) +
    scale_x_continuous(breaks = 1:16) +
    theme(panel.grid.minor = element_blank())

```

## Hyperparameters: Number of Fish & Iterations

In the second experiment, we assessed the impact of varying two critical hyperparameters, the number of fish and the number of iterations, on the execution time of the parallel FSB algorithm. The number of threads fixed at 4 and a static scheduling strategy was employed. The number of threads was fixed to 4, as this was the optimal number achieved in the previous experiment Similar to the first experiment, caching was not employed.

The graph below visualizes the relationship between the number of fish and the execution time (in seconds) for different numbers of iterations in the FSB algorithm. Increasing the number of fish, for a set number of iterations, results in a linear increase in execution time whereas increasing the number of iterations, for a set number of fish, results in a parabolic increase in execution time. This behavior is expected, as a larger population of fish and more iterations require more computation, resulting in longer execution times.

```{r, message=FALSE, warning=FALSE, echo=FALSE}
ggplot(
  data = data.frame(
    num_fish =  c(200000, 400000, 600000, 800000, 1000000),
    iter_20000 = c(117.350819, 237.082449, 397.935612, 482.203047, 653.402037),
    iter_40000 = c(234.463991, 466.925614, 700.021926, 936.720754, 1177.662832),
    iter_60000 = c(353.012268,
      701.901361,
      1050.975947,
      1418.876797,
      1777.164701),
    iter_80000 = c(471.402103,
      944.524666,
      1397.776130,
      1863.592248,
      2350.380621),
    iter_100000 = c(586.554482,
      1167.285182,
      1771.424057,
      2363.592248,
      2925.219894)),
  aes(x = num_fish)) +
  geom_smooth(aes(y = iter_20000, color = "20000"), method = "lm", se = FALSE) +
  geom_smooth(aes(y = iter_40000, color = "40000"), method = "lm", se = FALSE) +
  geom_smooth(aes(y = iter_60000, color = "60000"), method = "lm", se = FALSE) +
  geom_smooth(aes(y = iter_80000, color = "80000"), method = "lm", se = FALSE) +
  geom_smooth(aes(y = iter_100000, color = "100000"), method = "lm",
    se = FALSE) +
  geom_point(aes(y = iter_20000)) +
  geom_point(aes(y = iter_40000)) +
  geom_point(aes(y = iter_60000)) +
  geom_point(aes(y = iter_80000)) +
  geom_point(aes(y = iter_100000)) +
  geom_smooth(aes(y = c(117.350819,
    466.925614,
    1050.975947,
    1863.592248,
    2925.219894)),
    method = "lm",
    formula = y ~ poly(x, 2),
    linetype = "dotted",
    se = FALSE) +
  labs(title = "Execution Time vs Hyperparameters",
    x = "Number of Fish",
    y = "Time (s)",
    color = "Number of Iterations") +
  scale_color_manual(values = c(
    "20000" = "darkred",
    "40000" = "steelblue",
    "60000" = "magenta",
    "80000" = "darkgreen",
    "100000" = "pink4"))
```

## Thread Scheduling

In the third experiment, we investigated the impact of different thread scheduling strategies (static, dynamic, guided, and runtime) on the execution time of the parallelized FSB algorithm. The number of threads was fixed at 4, and the hyperparameters of number of fish and iterations were also kept constant at 1,000,000 and 100,000 respectively. 

The runtime scheduling has no chunk size as it is constantly being adjusted during runtime so in the graph it is kept as a straight line. As the time limit on Setonix is 1 hour, anything over 3600 seconds were run with fewer number of steps and scale the time back to the same as every other experiment, based on the previous experiments on Execution Time vs Hyperparameters we can conclude that execution time grows linerally with the nubmer of steps, so this estimate is accurate.

```{r, message=FALSE, warning=FALSE, echo=FALSE}
ggplot(
  data = data.frame(
    chunk_size = c(1, 2, 3, 4),
    static = c(3265.162540, 2784.864581, 3035.950782, 2918.142244),
    dynamic = c(4154.18010, 3073.691588, 2970.014433, 2982.671884),
    guided = c(3051.865076, 2937.002249, 2941.794308, 2973.637886),
    runtime = 4198.46404),
  aes(x = chunk_size)) +
  geom_smooth(aes(y = static, color = "static")) +
  geom_smooth(aes(y = dynamic, color = "dynamic")) +
  geom_smooth(aes(y = guided, color = "guided")) +
  geom_smooth(aes(y = runtime, color = "runtime"), linetype = "dashed") +
  geom_point(aes(y = static)) +
  geom_point(aes(y = dynamic)) +
  geom_point(aes(y = guided)) +
  labs(title = "Execution Time vs Scheduling Strategies",
    x = "Chunk Size",
    y = "Time (s)",
    color = "Scheduling Type") +
  scale_x_continuous(labels = c(1, 10, 100, 10000)) +
  scale_y_continuous(breaks = seq(2700, 4200, by = 300)) +
  scale_color_manual(values = c(
    "static" = "darkred",
    "dynamic" = "steelblue",
    "guided" = "magenta",
    "runtime" = "darkgreen"))
```

## OMP Directives 


```{r, message=FALSE, warning=FALSE, echo=FALSE}
ggplot(
  data = data.frame(
    omp_directive = c("OMP For",
      "OMP For Partition",
      "OMP Task Per Fish",
      "OMP Tasks"),
    time = c(295.652146,
      885.287894,
      4877.38059,
      305.464913),
    colour_group = c(rep("OMP For", 2), rep("OMP Task", 2))),
    aes(x = omp_directive, y = time, fill = colour_group)) +
  geom_bar(stat = "identity") +
  labs(title = "Execution Time for Different Implementations",
    x = "Implementations",
    y = "Time (s)",
    fill = "OMP Directives"
  )
```

## Cache Behaviour
