---
title: "CITS5507 Project 2: Parallel implementation of search based on MPI and OpenMP"

graphics: yes
author: Kaiqi Liang (23344153), Briana Davies-Morrell (22734723)
date: "Semester 2, 2023"
---

```{r, message=FALSE, warning=FALSE, echo=FALSE}
library(ggplot2)
library(knitr)
```

# Introduction

Fish School Behaviour (FSB) is a heuristic algorithm used for multi-dimensional optimization problems. The objective of this project was to parallelise a much simpler version of the FSB algorithm using MPI and OpenMP and perform a range of experiments assessing the impact of changing the number of nodes and threads within each node on execution time. All of the code can be found on [**GitHub**](https://github.com/Kaiqi-Liang/CITS5507-Project).

# Experiments

The experiments are broken down into 2 parts, one is on the sequential implementation with different hyperparameters, the other is on the parallel implementation with different number of MPI nodes and OpenMP threads. All the results have been measured several times and taken the average to get a better accuracy.

## Sequential Implementation & Experiments

To establish a baseline for comparison, a sequential C++ program was developed to simulate the behaviour of a fish school using the FSB algorithm.

The graph below visualizes the relationship between the number of fish and the execution time (in seconds) for a different number of iterations in the FSB algorithm. Increasing the number of fish, for a set number of iterations, or increasing the number of iterations, for a set number of fish, results in a linear increase in execution time. Increasing both the number of fish and iterations results in a parabolic increase in execution time. This behaviour is to be expected as the FSB algorithm consists of two nested loops over the number of iterations and fish and thus has a time complexity of O(FI) where F is the number of fish and I is the number of iterations. Overall, a larger population of fish and more iterations require more computation, resulting in longer execution times.

Our most computationally expensive experiment ran for 2780 seconds (~46 minutes) at 1,000,000 fish and 100,000 iterations. This value was used as a baseline for comparison for all parallel experiments.

```{r, message=FALSE, warning=FALSE, echo=FALSE}
ggplot(
  data = data.frame(
    num_fish =  c(200000, 400000, 600000, 800000, 1000000),
    iter_20000 = c(110.703507, 221.168173, 332.295848, 443.077424, 557.648611),
    iter_40000 = c(222.853256, 448.680679, 677.698978, 886.666866, 1112.435153),
    iter_60000 = c(
      334.170646,
      666.771699,
      1004.9347861,
      1455.1160081,
      1820.057278),
    iter_80000 = c(
      442.774348,
      887.792977,
      1337.221277,
      1789.476277,
      2263.432539),
    iter_100000 = c(
      575.766097,
      1126.112223,
      1697.037298,
      2230.462189,
      2780.588561)),
  aes(x = num_fish)) +
  geom_smooth(aes(y = iter_20000, color = "20000"), method = "lm", se = FALSE) +
  geom_smooth(aes(y = iter_40000, color = "40000"), method = "lm", se = FALSE) +
  geom_smooth(aes(y = iter_60000, color = "60000"), method = "lm", se = FALSE) +
  geom_smooth(aes(y = iter_80000, color = "80000"), method = "lm", se = FALSE) +
  geom_smooth(aes(y = iter_100000, color = "100000"), method = "lm",
    se = FALSE) +
  geom_point(aes(y = iter_20000)) +
  geom_point(aes(y = iter_40000)) +
  geom_point(aes(y = iter_60000)) +
  geom_point(aes(y = iter_80000)) +
  geom_point(aes(y = iter_100000)) +
  geom_smooth(aes(y = c(
    110.703507,
    448.680679,
    1004.9347861,
    1789.476277,
    2780.588561)),
    method = "lm",
    formula = y ~ poly(x, 2),
    linetype = "dotted",
    se = FALSE) +
  labs(title = "Execution Time vs Hyperparameters for Sequential Program",
    x = "Number of Fish",
    y = "Time (s)",
    color = "Number of Iterations") +
  scale_color_manual(values = c(
    "20000" = "darkred",
    "40000" = "steelblue",
    "60000" = "magenta",
    "80000" = "darkgreen",
    "100000" = "pink4"))
```

## Parallel Implementation & Experiments

A parallel implementation of the FSB algorithm was developed using OpenMP and MPI. We experimented with 2, 3, and 4 number of MPI nodes and 2, 4, 8, and 16 threads within each process. The results are given below

### Execution Time vs Number of MPI Nodes & OpenMP Threads

```{r, message=FALSE, warning=FALSE, echo=FALSE}
ggplot(
  data = data.frame(
    num_nodes =  c(1, 2, 3, 4),
    threads_2 = c(1,1,1,1),
    threads_4 = c(1,1,1,1),
    threads_8 = c(1,1,1,1),
    threads_16 = c(1,1,1,1)),
  aes(x = num_nodes)) +
  geom_smooth(aes(y = threads_2, color = "2"), se = FALSE) +
  geom_smooth(aes(y = threads_4, color = "4"), se = FALSE) +
  geom_smooth(aes(y = threads_8, color = "8"),  se = FALSE) +
  geom_smooth(aes(y = threads_16, color = "16"), se = FALSE) +
  geom_point(aes(y = threads_2)) +
  geom_point(aes(y = threads_4)) +
  geom_point(aes(y = threads_8)) +
  geom_point(aes(y = threads_16)) +
  labs(title = "Execution Time vs Number of MPI Nodes & OpenMP Threads",
    x = "Number of MPI Nodes",
    y = "Time (s)",
    color = "Number of Threads") +
  scale_color_manual(values = c(
    "2" = "darkred",
    "4" = "steelblue",
    "8" = "magenta",
    "16" = "darkgreen"))
```
